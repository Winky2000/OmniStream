<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>OmniStream</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="theme.css">
  <style>
    body{font-family:Segoe UI,Arial;background:var(--bg);color:var(--text-main);margin:0;padding:0}
    .app-shell{display:flex;min-height:100vh;}
    .sidebar{width:220px;background:#050814;border-right:1px solid rgba(15,23,42,0.8);padding:18px 16px;box-sizing:border-box;display:flex;flex-direction:column;gap:18px;}
    .sidebar-brand{font-size:13px;font-weight:600;letter-spacing:0.14em;text-transform:uppercase;color:var(--text-muted);}
    .sidebar-nav{display:flex;flex-direction:column;gap:4px;margin-top:8px;}
    .nav-link{display:block;padding:8px 10px;border-radius:8px;font-size:13px;color:var(--text-muted);text-decoration:none;transition:background 0.15s,color 0.15s;}
    .nav-link:hover{background:rgba(148,163,184,0.15);color:var(--text-main);}
    .nav-link-active{background:rgba(59,130,246,0.18);color:#e5edff;border-left:3px solid var(--btn-border);padding-left:7px;}
    .settings-group{margin-top:4px;}
    .settings-submenu{display:none;flex-direction:column;gap:2px;padding-left:14px;margin-top:3px;}
    .settings-submenu.open{display:flex;}
    .submenu-link{display:block;padding:6px 10px;border-radius:8px;font-size:12px;color:var(--text-muted);text-decoration:none;}
    .submenu-link:hover{background:rgba(148,163,184,0.15);color:var(--text-main);}
    .submenu-link-active{background:rgba(59,130,246,0.18);color:#e5edff;}
    .sidebar-toggle{margin-bottom:10px;padding:4px 10px;border-radius:999px;border:1px solid var(--btn-border);background:var(--btn-bg);color:var(--btn-text);cursor:pointer;font-size:12px;}
    .sidebar-toggle:hover{background:var(--btn-bg-hover);color:var(--btn-text-hover);}
    .app-shell.sidebar-collapsed .sidebar{display:none;}
    .main-content{flex:1;box-sizing:border-box;padding:20px;}
    h1{margin:0;color:var(--text-main);letter-spacing:0.5px;display:inline-block;vertical-align:middle;font-size:1.8em;font-weight:600;}
    .header-flex{display:flex;align-items:center;gap:14px;margin-bottom:20px;}
    .logo-img{height:72px;max-width:160px;object-fit:contain;border-radius:8px;}
    #grid.grid-layout {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 28px;
      align-items: flex-start;
      justify-content: flex-start;
    }
    #grid.flex-layout {
      display: flex;
      flex-direction: column;
      gap: 28px;
      align-items: center;
    }
    .card.flex-full {
      min-width: 100%;
      max-width: 100%;
      width: 100%;
    }
    .sessions.horizontal-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 18px;
      align-items: flex-start;
    }
    /* Card layout */
    .card {
      background: var(--card-bg);
      border-radius: 14px;
      padding: 24px 24px 20px 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      border: 1px solid rgba(148, 163, 184, 0.28);
      min-width: 420px;
      max-width: 520px;
      width: 100%;
      transition: border-color 0.2s, box-shadow 0.2s, transform 0.15s;
    }
    .card.card-plex,
    .card.card-jellyfin,
    .card.card-emby {
      border-color: rgba(148, 163, 184, 0.45);
      box-shadow: 0 18px 45px rgba(15,23,42,0.85);
    }

    /* Softer cards in light themes */
    :root[data-theme="light"] .card,
    :root[data-theme="light-borderless"] .card {
      border-radius: 14px;
      border-width: 1px;
      border-style: solid;
      border-color: #dddddd;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }
    :root[data-theme="light"] .card.card-plex,
    :root[data-theme="light"] .card.card-jellyfin,
    :root[data-theme="light"] .card.card-emby,
    :root[data-theme="light-borderless"] .card.card-plex,
    :root[data-theme="light-borderless"] .card.card-jellyfin,
    :root[data-theme="light-borderless"] .card.card-emby {
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      border-color: #dddddd;
    }
    :root[data-theme="light-borderless"] .card {
      border: none;
      box-shadow: none;
    }

    /* Softer session borders in light themes */
    :root[data-theme="light"] .session.direct,
    :root[data-theme="light"] .session.transcode,
    :root[data-theme="light-borderless"] .session.direct,
    :root[data-theme="light-borderless"] .session.transcode {
      box-shadow: none;
    }
    :root[data-theme="light"] .session.direct {
      border: 1px solid var(--session-direct);
    }
    :root[data-theme="light"] .session.transcode {
      border: 1px solid var(--session-transcode);
    }
    :root[data-theme="light-borderless"] .session.direct,
    :root[data-theme="light-borderless"] .session.transcode {
      border: none;
    }
    .card.offline {
      border-color: var(--border-offline);
      box-shadow: none;
      opacity: 0.65;
    }
    .toggle-btn{background:var(--btn-bg);color:var(--btn-text);border:2px solid var(--btn-border);border-radius:8px;padding:8px 18px;font-size:1em;cursor:pointer;margin-bottom:18px;transition:background 0.2s, color 0.2s, border-color 0.2s;}
    .toggle-btn:hover{background:var(--btn-bg-hover);color:var(--btn-text-hover);}
    .offline{opacity:0.5}
    .title{font-weight:600;margin-bottom:6px;color:var(--text-main)}
    .meta{font-size:13px;color:var(--text-muted);margin-bottom:8px}
    .small{font-size:12px;color:var(--text-faint);margin-bottom:8px}
    .sessions{font-size:11px;border-top:1px solid #222;padding-top:8px;margin-top:8px;display:flex;flex-direction:column;gap:8px;}
    .sessions.flex-sessions{flex-direction:row;flex-wrap:wrap;gap:18px;align-items:flex-start;}
    .session{
      background:var(--card-bg);
      padding:8px 10px;
      border-radius:8px;
      margin-bottom:8px;
      line-height:1.4;
      box-shadow:0 1px 3px rgba(15,23,42,0.75);
      display:flex;
      flex-direction:column;
      gap:4px;
      transition:transform 0.12s ease-out, box-shadow 0.12s ease-out, background 0.12s ease-out, border-color 0.12s ease-out;
    }
    .session:hover{
      transform:translateY(-1px);
      box-shadow:0 6px 18px rgba(15,23,42,0.85);
      background:rgba(15,23,42,0.75);
    }
    :root[data-theme="light"] .session:hover,
    :root[data-theme="light-borderless"] .session:hover{
      background:rgba(0,0,0,0.03);
      box-shadow:0 2px 4px rgba(0,0,0,0.12);
    }
    .session.direct{border:1px solid var(--session-direct);}
    .session.transcode{border:1px solid var(--session-transcode);}
    .session-user{font-weight:600;color:#f7c873;font-size:14px}
    .session-user a{color:#f7c873;text-decoration:none;}
    .session-user a:hover{text-decoration:underline;}
    .session-title{color:var(--text-main);font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .session-meta{font-size:11px;color:var(--text-muted);margin-bottom:2px}
    .session-poster{width:120px;object-fit:cover;margin-right:10px;border-radius:3px;box-shadow:0 1px 2px #0003;align-self:stretch}
    .session-poster-placeholder{
      display:flex;
      align-items:center;
      justify-content:center;
      background:linear-gradient(135deg,#ef4444,#f97316);
      color:#fef2f2;
      font-weight:700;
      font-size:24px;
      text-transform:uppercase;
    }
    .progress-bar{background:#2a2e39;height:4px;border-radius:2px;margin-top:2px;overflow:hidden}
    .progress-fill{background:var(--progress-fill);height:100%;transition:width 0.3s}
    .progress-meta{margin-top:3px;font-size:10px;color:var(--text-faint);display:flex;justify-content:space-between;align-items:flex-start;gap:6px;}
    .progress-meta-left{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--text-main);font-weight:600;font-size:11px;}
    .badge-row{margin-top:4px;display:flex;flex-wrap:wrap;gap:4px;align-items:center;}
    .badge{font-size:10px;padding:1px 6px;border-radius:999px;border:1px solid rgba(255,255,255,0.16);background:rgba(0,0,0,0.3);color:var(--text-main);white-space:nowrap;}
    .badge-wan{border-color:#ff7043;color:#ffab91;}
    .badge-hdr{border-color:#ffca28;color:#ffecb3;}
    .badge-uhd{border-color:#29b6f6;color:#b3e5fc;}
    .badge-codec{border-color:#81c784;color:#c8e6c9;}
    .badge-product{border-color:#b39ddb;color:#e1bee7;}
    .badge-health-good{border-color:#4caf50;color:#c8e6c9;}
    .badge-health-warn{border-color:#ffb300;color:#ffe082;}
    .badge-health-bad{border-color:#e53935;color:#ffab91;}
  </style>
</head>
<body>
  <div class="app-shell">
    <aside class="sidebar">
      <div class="sidebar-brand">OmniStream</div>
      <nav class="sidebar-nav">
        <a href="index.html" class="nav-link nav-link-active">Dashboard</a>
        <a href="history.html" class="nav-link">History</a>
        <a href="reports.html" class="nav-link">Reports</a>
        <a href="notifications.html" class="nav-link">Notifications</a>
        <div class="settings-group">
          <button type="button" class="nav-link settings-toggle">Settings</button>
          <div class="settings-submenu">
            <a href="admin.html" class="submenu-link">Connected servers</a>
            <a href="servers.html" class="submenu-link">Servers</a>
            <a href="display.html" class="submenu-link">Themes &amp; layout</a>
            <a href="notifiers.html" class="submenu-link">Notifiers</a>
            <a href="system.html" class="submenu-link">System</a>
          </div>
        </div>
      </nav>
    </aside>
    <main class="main-content">
      <button class="sidebar-toggle" id="sidebarToggle">Hide menu</button>
      <div class="header-flex">
        <img src="omnistream_logo.png" alt="OmniStream Logo" class="logo-img" />
        <h1>OmniStream</h1>
      </div>
      <div id="grid" class="grid-layout"></div>
    </main>
  </div>

  <script>
    // Apply saved theme from Settings
    (function() {
      const savedTheme = localStorage.getItem('omnistreamTheme') || 'default';
      if (savedTheme && savedTheme !== 'default') {
        document.documentElement.setAttribute('data-theme', savedTheme);
      } else {
        document.documentElement.removeAttribute('data-theme');
      }
    })();

    async function fetchStatus() {
      try {
        const r = await fetch('/api/status');
        return await r.json();
      } catch (e) { console.error(e); return {servers: [], statuses: {}} }
    }

    // Track the last rendered snapshot so we only re-render
    // when something important changes (server online state
    // or active session counts). This reduces visible flashing
    // when polling.
    let lastRenderSignature = null;

    let layoutMode = 'grid';
    document.addEventListener('DOMContentLoaded', () => {
      const grid = document.getElementById('grid');
      const settingsToggle = document.querySelector('.settings-toggle');
      const settingsSubmenu = document.querySelector('.settings-submenu');
      // Apply saved layout mode from Settings (default to grid)
      const savedLayout = localStorage.getItem('omnistreamLayout') || 'grid';
      layoutMode = savedLayout === 'flex' ? 'flex' : 'grid';
      grid.className = layoutMode === 'grid' ? 'grid-layout' : 'flex-layout';

      if (settingsToggle && settingsSubmenu) {
        settingsToggle.addEventListener('click', () => {
          settingsSubmenu.classList.toggle('open');
        });
      }

      const appShell = document.querySelector('.app-shell');
      const sidebarToggle = document.getElementById('sidebarToggle');
      if (appShell && sidebarToggle) {
        const savedSidebar = localStorage.getItem('omnistreamSidebar') || 'open';
        if (savedSidebar === 'collapsed') {
          appShell.classList.add('sidebar-collapsed');
          sidebarToggle.textContent = 'Show menu';
        }
        sidebarToggle.addEventListener('click', () => {
          const collapsed = appShell.classList.toggle('sidebar-collapsed');
          sidebarToggle.textContent = collapsed ? 'Show menu' : 'Hide menu';
          localStorage.setItem('omnistreamSidebar', collapsed ? 'collapsed' : 'open');
        });
      }
    });

    function render(data) {
      const { servers = [], statuses = {}, setup = false } = data;
      const grid = document.getElementById('grid');
      const sidebar = document.querySelector('.sidebar');
      const layoutToggle = document.getElementById('layoutToggle');
      const fragment = document.createDocumentFragment();
      // Setup mode: no servers configured yet
      if (setup || !servers.length) {
        if (sidebar) sidebar.style.display = 'none';
        if (layoutToggle) layoutToggle.style.display = 'none';
        const card = document.createElement('div');
        card.className = 'card flex-full';
        const title = document.createElement('div');
        title.className = 'title';
        title.textContent = 'Welcome to OmniStream';
        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.innerHTML = 'No servers are configured yet.<br>Add your Plex/Jellyfin/Emby servers to get started.';
        const btn = document.createElement('button');
        btn.className = 'toggle-btn';
        btn.style.marginTop = '16px';
        btn.textContent = 'Start Setup (Servers)';
        btn.onclick = () => { window.location.href = '/servers.html'; };
        card.appendChild(title);
        card.appendChild(meta);
        card.appendChild(btn);
        grid.appendChild(card);
        return;
      }
      if (sidebar) sidebar.style.display = '';
      if (layoutToggle) layoutToggle.style.display = '';
      servers.forEach(s => {
        const st = statuses && statuses[s.id] ? statuses[s.id] : { online: false };
        const card = document.createElement('div');
        const typeClass = s.type ? ('card-' + s.type.toLowerCase()) : '';
        card.className = 'card ' + typeClass + ' ' + (st.online ? '' : 'offline') + (layoutMode === 'flex' ? ' flex-full' : '');
        // In flex (horizontal) mode, cards are 100% width; in grid (vertical), cards are full width
        if (layoutMode === 'flex') {
          card.style.minWidth = '100%';
          card.style.maxWidth = '100%';
          card.style.width = '100%';
        } else {
          card.style.minWidth = '420px';
          card.style.maxWidth = '520px';
          card.style.width = '100%';
        }

        const title = document.createElement('div'); title.className = 'title';
        title.textContent = s.name || s.baseUrl;

        const meta = document.createElement('div'); meta.className = 'meta';
        meta.textContent = `${s.type || 'generic'} \u2022 ${st.online ? 'Online' : 'Offline'}`;

        const small = document.createElement('div'); small.className = 'small';
        small.innerHTML = `Latency: ${st.latency ?? '-'}ms<br/>Last: ${st.lastChecked ? new Date(st.lastChecked).toLocaleTimeString() : '-'}`;

        card.appendChild(title); 
        card.appendChild(meta); 
        card.appendChild(small);
        // Session summary with totals (always show, default to zero if missing)
        if (st.online) {
          const summary = st.summary || {};
          const directPlays = typeof summary.directPlays === 'number' ? summary.directPlays : 0;
          const transcodes = typeof summary.transcodes === 'number' ? summary.transcodes : 0;
          // Always use st.sessions.length for totalStreams if available
          const totalStreams = st.sessions && Array.isArray(st.sessions) ? st.sessions.length : (typeof summary.totalStreams === 'number' ? summary.totalStreams : 0);
          // If summary.totalBandwidth is zero, sum from sessions
          let totalBandwidth = typeof summary.totalBandwidth === 'number' ? summary.totalBandwidth : 0;
          if (totalBandwidth === 0 && st.sessions && Array.isArray(st.sessions)) {
            totalBandwidth = st.sessions.reduce((sum, sess) => sum + (typeof sess.bandwidth === 'number' ? sess.bandwidth : 0), 0);
          }
          let lanBandwidth = typeof summary.lanBandwidth === 'number' ? summary.lanBandwidth : 0;
          let wanBandwidth = typeof summary.wanBandwidth === 'number' ? summary.wanBandwidth : 0;
          // If LAN/WAN bandwidth is zero, sum from sessions
          if (lanBandwidth === 0 && st.sessions && Array.isArray(st.sessions)) {
            lanBandwidth = st.sessions.reduce((sum, sess) => sum + (sess.location && sess.location.toUpperCase().includes('LAN') && typeof sess.bandwidth === 'number' ? sess.bandwidth : 0), 0);
          }
          if (wanBandwidth === 0 && st.sessions && Array.isArray(st.sessions)) {
            wanBandwidth = st.sessions.reduce((sum, sess) => sum + (sess.location && sess.location.toUpperCase().includes('WAN') && typeof sess.bandwidth === 'number' ? sess.bandwidth : 0), 0);
          }
          const latencyMs = typeof st.latency === 'number' ? st.latency : null;
          let healthLabel = 'Unknown';
          let healthClass = '';
          if (latencyMs == null) {
            healthLabel = 'Health unknown';
          } else if (latencyMs < 200) {
            healthLabel = 'Healthy';
            healthClass = 'badge-health-good';
          } else if (latencyMs < 600) {
            healthLabel = 'Okay';
            healthClass = 'badge-health-warn';
          } else {
            healthLabel = 'Slow';
            healthClass = 'badge-health-bad';
          }
          const summaryDiv = document.createElement('div');
          summaryDiv.className = 'meta';
          summaryDiv.innerHTML = `Total Streams: <b>${totalStreams}</b> &nbsp;|&nbsp; Direct Play: <b>${directPlays}</b> &nbsp;|&nbsp; Transcoding: <b>${transcodes}</b><br>Bandwidth: ${totalBandwidth.toFixed(1)} Mbps (LAN: ${lanBandwidth.toFixed(1)} Mbps, WAN: ${wanBandwidth.toFixed(1)} Mbps)`;
          const healthSpan = document.createElement('span');
          healthSpan.className = 'badge' + (healthClass ? ' ' + healthClass : '');
          healthSpan.style.marginLeft = '6px';
          healthSpan.textContent = healthLabel;
          summaryDiv.appendChild(document.createTextNode(' '));
          summaryDiv.appendChild(healthSpan);
          card.appendChild(summaryDiv);
        }
        // Sessions
        if (st.online && st.sessions && st.sessions.length > 0) {
          const sessionsDiv = document.createElement('div');
          sessionsDiv.className = 'sessions' + (layoutMode === 'flex' ? ' horizontal-grid' : '');
          // Filter out any completely empty session objects so we don't render blank cards
          const visibleSessions = st.sessions.filter(sess => sess && (sess.poster || sess.title || sess.user || sess.userName));
          visibleSessions.forEach(sess => {
            const session = document.createElement('div');
            // Classify direct play vs transcode for border color
            let isTranscoding = false;
            if (typeof sess.transcoding === 'boolean') {
              isTranscoding = sess.transcoding;
            } else if (sess.stream && typeof sess.stream === 'string' && sess.stream.toLowerCase().includes('transcode')) {
              isTranscoding = true;
            } else if (sess.state && typeof sess.state === 'string' && sess.state.toLowerCase().includes('transcode')) {
              isTranscoding = true;
            }
            session.className = 'session ' + (isTranscoding ? 'transcode' : 'direct');
            // Layout: poster left, info right (horizontal) or stacked (vertical)
            const row = document.createElement('div');
            // Always use a flex row for session content so poster and text line up
            row.style.display = 'flex';
            row.style.alignItems = 'stretch';
            // Poster (with OTA / fallback placeholder when artwork is missing)
            function createPosterPlaceholder() {
              const ph = document.createElement('div');
              ph.className = 'session-poster session-poster-placeholder';
              const channel = (sess.channel || '').toString().trim();
              const titleText = (sess.title || '').toString().trim();
              let text = '';
              if (channel) {
                text = channel.slice(0, 3).toUpperCase();
              } else if (titleText) {
                text = titleText.slice(0, 1).toUpperCase();
              } else {
                text = 'TV';
              }
              ph.textContent = text;
              ph.title = channel || titleText || 'Live TV';
              return ph;
            }
            if (sess.poster) {
              const img = document.createElement('img');
              img.className = 'session-poster';
              img.src = sess.poster;
              img.alt = 'Poster';
              img.onerror = function() {
                // If the artwork fails to load (e.g. OTA without poster),
                // replace it with a styled placeholder so the layout
                // still shows a "poster" block.
                if (this.parentNode) {
                  this.parentNode.replaceChild(createPosterPlaceholder(), this);
                }
              };
              row.appendChild(img);
            } else {
              row.appendChild(createPosterPlaceholder());
            }
            // Info block
            const info = document.createElement('div');
            info.style.display = 'flex';
            info.style.flexDirection = 'column';
            info.style.marginLeft = layoutMode === 'flex' ? '10px' : '0';
            // User and title
            const title = document.createElement('div');
            title.className = 'session-user';
            const userName = sess.user || sess.userName || 'Unknown';
            if (userName) {
              const userLink = document.createElement('a');
              userLink.href = 'user.html?user=' + encodeURIComponent(userName);
              userLink.textContent = userName;
              title.appendChild(userLink);
            } else {
              title.textContent = userName;
            }
            // Direct Play/Transcoding label
            const streamType = document.createElement('span');
            streamType.style = 'margin-left:8px;font-size:11px;padding:2px 8px;border-radius:6px;font-weight:600;display:inline-block;';
            if (isTranscoding) {
              streamType.textContent = 'Transcoding';
              streamType.style.background = 'var(--session-transcode)';
              streamType.style.color = '#ffffff';
            } else {
              streamType.textContent = 'Direct Play';
              streamType.style.background = 'var(--session-direct)';
              streamType.style.color = '#000000';
            }
            title.appendChild(streamType);
            info.appendChild(title);
            // Title line: treat live/OTA differently from library episodes
            let displayTitle;
            const isLive = !!sess.isLive;
            const hasEpisode = !!(sess.episode || sess.episodeTitle);
            if (isLive) {
              const channelName = sess.channel || 'Live TV';
              const program = sess.title || sess.episodeTitle || '';
              displayTitle = program ? `${channelName} - ${program}` : channelName;
            } else if (hasEpisode) {
              const showName = sess.seriesTitle || sess.title || sess.channel || 'Unknown Show';
              const episodeName = sess.episode || sess.episodeTitle || sess.title || 'Episode';
              displayTitle = `${showName} - ${episodeName}`;
            } else {
              displayTitle = sess.title || sess.channel || 'Idle';
            }
            // If we have season/episode numbers, show them under the title
            if (typeof sess.seasonNumber === 'number' || typeof sess.episodeNumber === 'number') {
              const seLine = document.createElement('div');
              seLine.className = 'session-meta';
              let parts = [];
              if (typeof sess.seasonNumber === 'number') parts.push('Season ' + sess.seasonNumber);
              if (typeof sess.episodeNumber === 'number') parts.push('Episode ' + sess.episodeNumber);
              seLine.textContent = parts.join(' • ');
              info.appendChild(seLine);
            }
            // Badge row: WAN / HDR / 4K / codec / product
            const badgeRow = document.createElement('div');
            badgeRow.className = 'badge-row';
            function addBadge(text, extraClass, titleText) {
              if (!text) return;
              const b = document.createElement('span');
              b.className = 'badge' + (extraClass ? ' ' + extraClass : '');
              b.textContent = text;
              if (titleText) b.title = titleText;
              badgeRow.appendChild(b);
            }
            const isWan = sess.location && sess.location.toUpperCase().includes('WAN');
            if (isWan) addBadge('WAN', 'badge-wan', 'WAN session');
            const qualityStr = (sess.quality || sess.video || '').toString().toUpperCase();
            const is4K = qualityStr.includes('4K') || qualityStr.includes('2160');
            if (is4K) addBadge('4K', 'badge-uhd', 'Ultra HD');
            const videoInfo = (sess.video || '').toString().toUpperCase();
            const isHdr = videoInfo.includes('HDR') || videoInfo.includes('DOLBY VISION') || videoInfo.includes('HLG');
            if (isHdr) addBadge('HDR', 'badge-hdr', 'High Dynamic Range');
            if (sess.video) {
              const codecMatch = sess.video.match(/([A-Za-z0-9]+)(?:\s|\/|$)/);
              if (codecMatch && codecMatch[1]) {
                addBadge(codecMatch[1].toUpperCase(), 'badge-codec', sess.video);
              }
            }
            if (sess.product) {
              addBadge(sess.product, 'badge-product', 'Client: ' + sess.product);
            }
            if (badgeRow.childNodes.length > 0) {
              info.appendChild(badgeRow);
            }
            // Info list
            const infoList = document.createElement('div');
            infoList.style.fontSize = '11px';
            infoList.style.color = '#b0b3b8';
            infoList.style.display = 'flex';
            infoList.style.flexDirection = 'column';
            infoList.style.gap = '2px';
            function addInfo(label, value) {
              if (value) {
                const div = document.createElement('div');
                div.innerHTML = `<b>${label}:</b> ${value}`;
                div.title = `${label}: ${value}`;
                infoList.appendChild(div);
              }
            }
            addInfo('Product', sess.product);
            addInfo('Player', sess.player);
            addInfo('Quality', sess.quality);
            addInfo('Stream', sess.stream);
            addInfo('Container', sess.container);
            addInfo('Video', sess.video);
            addInfo('Audio', sess.audio);
            addInfo('Subtitle', sess.subtitle);
            addInfo('Location', sess.location);
            addInfo('Channel', sess.channel);
            if (sess.location && sess.location.toUpperCase().includes('WAN')) {
              addInfo('WAN', sess.ip);
            }
            if (typeof sess.bandwidth === 'number' && sess.bandwidth > 0) {
              addInfo('Bandwidth', sess.bandwidth.toFixed(1) + ' Mbps');
            }
            info.appendChild(infoList);
            row.appendChild(info);
            // Append the combined row for both layouts so sessions never appear empty
            session.appendChild(row);
            // Progress bar + meta (▶ Playing, elapsed/total, ETA)
            const bar = document.createElement('div');
            bar.className = 'progress-bar';
            const fill = document.createElement('div');
            fill.className = 'progress-fill';
            fill.style.width = (sess.progress || 0) + '%';
            bar.appendChild(fill);
            session.appendChild(bar);

            const progressMeta = document.createElement('div');
            progressMeta.className = 'progress-meta';
            const durationSec = typeof sess.duration === 'number' ? sess.duration : 0;
            const offsetSec = typeof sess.viewOffset === 'number' ? sess.viewOffset : 0;
            function fmtHM(sec) {
              if (!sec || sec <= 0 || !isFinite(sec)) return '0:00';
              const h = Math.floor(sec / 3600);
              const m = Math.floor((sec % 3600) / 60).toString().padStart(2, '0');
              return h + ':' + m;
            }
            const playedStr = durationSec > 0 ? fmtHM(offsetSec) : '--:--';
            const totalStr = durationSec > 0 ? fmtHM(durationSec) : '--:--';
            const remainingSec = durationSec > 0 && offsetSec >= 0 && offsetSec < durationSec
              ? (durationSec - offsetSec)
              : 0;
            let endTimeStr = '';
            if (remainingSec > 0) {
              const endDate = new Date(Date.now() + remainingSec * 1000);
              endTimeStr = endDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            }
            const leftSpan = document.createElement('span');
            leftSpan.className = 'progress-meta-left';
            leftSpan.textContent = displayTitle ? `▶ ${displayTitle}` : '▶ Playing';

            const rightBox = document.createElement('div');
            rightBox.style.display = 'flex';
            rightBox.style.flexDirection = 'column';
            rightBox.style.alignItems = 'flex-end';

            if (endTimeStr) {
              const etaSpan = document.createElement('span');
              etaSpan.textContent = `Ends at ${endTimeStr}`;
              rightBox.appendChild(etaSpan);
            }

            const lengthSpan = document.createElement('span');
            lengthSpan.textContent = `${playedStr} / ${totalStr}`;
            rightBox.appendChild(lengthSpan);

            progressMeta.appendChild(leftSpan);
            progressMeta.appendChild(rightBox);
            session.appendChild(progressMeta);
            sessionsDiv.appendChild(session);
          });
          if (visibleSessions.length > 0) {
            card.appendChild(sessionsDiv);
          }
        }
        fragment.appendChild(card);
      });
      // Swap the entire grid in one go to minimize flashing
      grid.replaceChildren(fragment);
      // After rendering, equalize session heights in horizontal layout
      equalizeSessionHeights();
    }

    function equalizeSessionHeights() {
      if (layoutMode !== 'flex') return; // only for horizontal
      const containers = document.querySelectorAll('.sessions.horizontal-grid');
      containers.forEach(container => {
        const sessions = Array.from(container.querySelectorAll('.session'));
        if (!sessions.length) return;
        let max = 0;
        sessions.forEach(s => {
          s.style.minHeight = '';
          if (s.offsetHeight > max) max = s.offsetHeight;
        });
        sessions.forEach(s => {
          s.style.minHeight = max + 'px';
        });
      });
    }

    function summarizeForSignature(data) {
      try {
        const servers = Array.isArray(data.servers) ? data.servers : [];
        const statuses = data.statuses || {};
        const summary = servers.map(s => {
          const st = statuses[s.id] || {};
          const sessions = Array.isArray(st.sessions) ? st.sessions : [];
          return {
            id: s.id,
            online: !!st.online,
            sessionCount: sessions.length
          };
        });
        // Sort to make the signature order-independent
        summary.sort((a, b) => String(a.id).localeCompare(String(b.id)));
        return JSON.stringify(summary);
      } catch (e) {
        console.error('Failed to build render signature', e);
        return null;
      }
    }

    async function loop() {
      const data = await fetchStatus();
      const sig = summarizeForSignature(data);
      if (sig && sig === lastRenderSignature) {
        return; // nothing meaningful changed; skip re-render
      }
      lastRenderSignature = sig;
      render(data);
    }

    // Initial load
    loop();
    // Poll less aggressively to reduce visual flashing while keeping data fresh
    setInterval(loop, 10000);
  </script>
</body>
</html>
